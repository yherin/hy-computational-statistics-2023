This question requires careful handling of numerical computations, particularly when working with log-probabilities, to avoid numerical underflow or overflow. Here's how you could implement each part in Python:

Firstly, you should create a Python script named `problem2.py`. Make sure to add necessary imports at the beginning of your script. Here's a template to get started:

```python
# problem2.py
import numpy as np
from scipy.special import gammaln, multigammaln

def lp1(x, v, w):
    """
    Compute the log-probability of a mixture of K Nakagami distributions.

    :param x: scalar, value at which to evaluate the log-probability.
    :param v: 1D numpy array of shape (K,), the v parameters of the distributions.
    :param w: 1D numpy array of shape (K,), the mixture weights.
    :return: scalar, the log-probability of the mixture at x.
    """
    # Protection against invalid values
    if x <= 0:
        return -np.inf

    # Calculating the components of the Nakagami distribution
    terms = w + np.log(2) + v * np.log(v) - gammaln(v) + (2 * v - 1) * np.log(x) - v * x**2

    # Log-sum-exp trick for numerical stability when summing the mixture components
    max_term = np.max(terms)
    sum_exp = np.sum(np.exp(terms - max_term))

    log_prob = max_term + np.log(sum_exp)
    return log_prob


def lp2(X, Psi, nu):
    """
    Compute the log-probability of the inverse-Wishart distribution.

    :param X: 2D numpy array of shape (p, p), the matrix at which to evaluate the log-probability.
    :param Psi: 2D numpy array of shape (p, p), the scale matrix of the distribution.
    :param nu: scalar, the degrees of freedom of the distribution.
    :return: scalar, the log-probability of the distribution at X.
    """
    p = X.shape[0]  # Dimensionality of the matrices

    # Ensure the matrices are symmetric positive definite
    if not np.allclose(X, X.T) or not np.all(np.linalg.eigvals(X) > 0):
        return -np.inf
    if not np.allclose(Psi, Psi.T) or not np.all(np.linalg.eigvals(Psi) > 0):
        return -np.inf

    # Calculating components of the inverse-Wishart distribution
    term1 = 0.5 * nu * np.log(np.linalg.det(Psi))
    term2 = -0.5 * nu * p * np.log(2)
    term3 = -multigammaln(0.5 * nu, p)
    term4 = -0.5 * (nu + p + 1) * np.log(np.linalg.det(X))

    # Efficient trace calculation using einsum
    X_inv = np.linalg.inv(X)  # Inverting the matrix
    term5 = -0.5 * np.einsum('ij,ji->', Psi, X_inv)  # Trace of the product of Psi and X^-1

    log_prob = term1 + term2 + term3 + term4 + term5
    return log_prob

# This is just for testing; your function definitions should be above this line
if __name__ == "__main__":
    # Test your functions here using some sample parameters and values
    pass
```

After creating `problem2.py`, you would write test cases in the `if __name__ == "__main__":` block or in a separate Python script to ensure that your functions behave as expected. Ensure that you test edge cases, such as when matrices are not invertible, when values are at the extremes of the allowable ranges, or when inputs might cause numerical instability.

Finally, you would submit this `.py` file as per the instructions provided in the question, ensuring you follow any naming and submission protocols outlined by the examination or assignment guidelines.